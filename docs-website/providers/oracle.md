# Oracle

Oracle Database is a powerful enterprise relational database management system. FluentMigrator provides comprehensive support for Oracle, including Oracle-specific data types, features, and optimizations.

## Getting Started with Oracle

### Installation

Install the Oracle provider package:

```bash
# For .NET CLI
dotnet add package FluentMigrator.Runner.Oracle

# For Package Manager Console
Install-Package FluentMigrator.Runner.Oracle
```

### Basic Configuration

```csharp
services.AddFluentMigratorCore()
    .ConfigureRunner(rb => rb
        .AddOracle()
        .WithGlobalConnectionString(connectionString)
        .ScanIn(Assembly.GetExecutingAssembly()).For.Migrations())
    .AddLogging(lb => lb.AddFluentMigratorConsole());
```

### Connection String Examples

```csharp
// Basic connection with TNS
"Data Source=myserver:1521/XE;User Id=myuser;Password=mypassword;"

// Using TNS Names
"Data Source=ORCL;User Id=myuser;Password=mypassword;"

// Connection with connection pooling
"Data Source=myserver:1521/XE;User Id=myuser;Password=mypassword;Pooling=true;Min Pool Size=0;Max Pool Size=100;"

// Oracle Cloud connection
"Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCPS)(HOST=myhost.oraclecloud.com)(PORT=1522))(CONNECT_DATA=(SERVICE_NAME=myservice_high)));User Id=myuser;Password=mypassword;SSL_SERVER_CERT_DN=\"CN=myhost.oraclecloud.com,O=Oracle Corporation,L=Redwood City,ST=California,C=US\";"

// Using Easy Connect
"Data Source=myserver.domain.com:1521/myservice;User Id=myuser;Password=mypassword;"
```

## Oracle Data Types

### Basic Oracle Data Types

```csharp
public class OracleDataTypes : Migration
{
    public override void Up()
    {
        Create.Table("OracleTypeExamples")
            .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()

            // Numeric types
            .WithColumn("NumberValue").AsCustom("NUMBER").NotNullable()
            .WithColumn("IntegerValue").AsCustom("NUMBER(10)").NotNullable()
            .WithColumn("DecimalValue").AsDecimal(10, 2).NotNullable()
            .WithColumn("FloatValue").AsCustom("FLOAT").NotNullable()
            .WithColumn("BinaryFloatValue").AsCustom("BINARY_FLOAT").Nullable()
            .WithColumn("BinaryDoubleValue").AsCustom("BINARY_DOUBLE").Nullable()

            // String types
            .WithColumn("VarChar2Value").AsString(4000).NotNullable()
            .WithColumn("CharValue").AsFixedLengthString(10).NotNullable()
            .WithColumn("NCHARValue").AsCustom("NCHAR(10)").Nullable()
            .WithColumn("NVARCHAR2Value").AsCustom("NVARCHAR2(2000)").Nullable()
            .WithColumn("ClobValue").AsCustom("CLOB").Nullable()
            .WithColumn("NClobValue").AsCustom("NCLOB").Nullable()

            // Date and time types
            .WithColumn("DateValue").AsDateTime().NotNullable()
            .WithColumn("TimestampValue").AsCustom("TIMESTAMP").NotNullable()
            .WithColumn("TimestampTZValue").AsCustom("TIMESTAMP WITH TIME ZONE").Nullable()
            .WithColumn("TimestampLTZValue").AsCustom("TIMESTAMP WITH LOCAL TIME ZONE").Nullable()
            .WithColumn("IntervalYMValue").AsCustom("INTERVAL YEAR TO MONTH").Nullable()
            .WithColumn("IntervalDSValue").AsCustom("INTERVAL DAY TO SECOND").Nullable()

            // Binary types
            .WithColumn("RawValue").AsCustom("RAW(2000)").Nullable()
            .WithColumn("BlobValue").AsBinary().Nullable()

            // Special types
            .WithColumn("RowIdValue").AsCustom("ROWID").Nullable()
            .WithColumn("URowIdValue").AsCustom("UROWID").Nullable();

        // Create sequence for primary key (Oracle 11g and earlier)
        Execute.Sql("CREATE SEQUENCE SEQ_OracleTypeExamples START WITH 1 INCREMENT BY 1");

        // Create trigger for auto-increment (Oracle 11g and earlier)
        Execute.Sql(@"
            CREATE OR REPLACE TRIGGER TR_OracleTypeExamples_BI
            BEFORE INSERT ON OracleTypeExamples
            FOR EACH ROW
            BEGIN
                IF :NEW.Id IS NULL THEN
                    SELECT SEQ_OracleTypeExamples.NEXTVAL INTO :NEW.Id FROM DUAL;
                END IF;
            END;");
    }

    public override void Down()
    {
        Execute.Sql("DROP TRIGGER TR_OracleTypeExamples_BI");
        Execute.Sql("DROP SEQUENCE SEQ_OracleTypeExamples");
        Delete.Table("OracleTypeExamples");
    }
}
```

### Oracle 12c+ Identity Columns

```csharp
public class OracleIdentityColumns : Migration
{
    public override void Up()
    {
        // Oracle 12c+ supports IDENTITY columns (similar to SQL Server)
        Execute.Sql(@"
            CREATE TABLE ModernOracleTable (
                Id NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
                Name VARCHAR2(100) NOT NULL,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT PK_ModernOracleTable PRIMARY KEY (Id)
            )");

        // Alternative syntax for always generating identity
        Execute.Sql(@"
            CREATE TABLE AlwaysIdentityTable (
                Id NUMBER GENERATED ALWAYS AS IDENTITY (START WITH 1000 INCREMENT BY 10),
                Description VARCHAR2(500),
                CONSTRAINT PK_AlwaysIdentityTable PRIMARY KEY (Id)
            )");

        // Insert data without specifying ID
        Insert.IntoTable("ModernOracleTable")
            .Row(new { Name = "First Record" })
            .Row(new { Name = "Second Record" });
    }

    public override void Down()
    {
        Execute.Sql("DROP TABLE AlwaysIdentityTable");
        Execute.Sql("DROP TABLE ModernOracleTable");
    }
}
```

## Oracle-Specific Features

### Partitioning

```csharp
public class OraclePartitioning : Migration
{
    public override void Up()
    {
        // Range partitioning by date
        Execute.Sql(@"
            CREATE TABLE SalesData (
                Id NUMBER,
                SaleDate DATE NOT NULL,
                Amount NUMBER(10,2) NOT NULL,
                CustomerId NUMBER NOT NULL,
                RegionId NUMBER NOT NULL,
                CONSTRAINT PK_SalesData PRIMARY KEY (Id, SaleDate)
            )
            PARTITION BY RANGE (SaleDate) (
                PARTITION p2022 VALUES LESS THAN (DATE '2023-01-01'),
                PARTITION p2023 VALUES LESS THAN (DATE '2024-01-01'),
                PARTITION p2024 VALUES LESS THAN (DATE '2025-01-01'),
                PARTITION pMAXVALUE VALUES LESS THAN (MAXVALUE)
            )");

        // Hash partitioning for even distribution
        Execute.Sql(@"
            CREATE TABLE CustomerData (
                Id NUMBER PRIMARY KEY,
                Name VARCHAR2(100) NOT NULL,
                Email VARCHAR2(255) NOT NULL,
                CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
            PARTITION BY HASH (Id) PARTITIONS 8");

        // List partitioning by region
        Execute.Sql(@"
            CREATE TABLE RegionalData (
                Id NUMBER,
                Region VARCHAR2(20) NOT NULL,
                Data VARCHAR2(1000),
                CONSTRAINT PK_RegionalData PRIMARY KEY (Id, Region)
            )
            PARTITION BY LIST (Region) (
                PARTITION p_north_america VALUES ('USA', 'CANADA', 'MEXICO'),
                PARTITION p_europe VALUES ('UK', 'GERMANY', 'FRANCE', 'SPAIN'),
                PARTITION p_asia VALUES ('JAPAN', 'CHINA', 'INDIA', 'KOREA'),
                PARTITION p_others VALUES (DEFAULT)
            )");

        // Create local indexes on partitioned tables
        Execute.Sql("CREATE INDEX IX_SalesData_CustomerId ON SalesData (CustomerId) LOCAL");
        Execute.Sql("CREATE INDEX IX_SalesData_Amount ON SalesData (Amount) LOCAL");
    }

    public override void Down()
    {
        Execute.Sql("DROP TABLE RegionalData");
        Execute.Sql("DROP TABLE CustomerData");
        Execute.Sql("DROP TABLE SalesData");
    }
}
```

### Oracle Sequences and Triggers

```csharp
public class OracleSequencesAndTriggers : Migration
{
    public override void Up()
    {
        // Create table
        Create.Table("Products")
            .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("Name").AsString(100).NotNullable()
            .WithColumn("Description").AsString(2000).Nullable()
            .WithColumn("Price").AsDecimal(10, 2).NotNullable()
            .WithColumn("CategoryId").AsInt32().NotNullable()
            .WithColumn("CreatedAt").AsDateTime().NotNullable()
            .WithColumn("UpdatedAt").AsDateTime().NotNullable()
            .WithColumn("Version").AsInt32().NotNullable().WithDefaultValue(1);

        // Create sequence
        Execute.Sql("CREATE SEQUENCE SEQ_Products START WITH 1 INCREMENT BY 1 CACHE 20");

        // Create auto-increment trigger
        Execute.Sql(@"
            CREATE OR REPLACE TRIGGER TR_Products_BI
            BEFORE INSERT ON Products
            FOR EACH ROW
            BEGIN
                IF :NEW.Id IS NULL THEN
                    SELECT SEQ_Products.NEXTVAL INTO :NEW.Id FROM DUAL;
                END IF;

                :NEW.CreatedAt := SYSDATE;
                :NEW.UpdatedAt := SYSDATE;
            END;");

        // Create update trigger for timestamp and version
        Execute.Sql(@"
            CREATE OR REPLACE TRIGGER TR_Products_BU
            BEFORE UPDATE ON Products
            FOR EACH ROW
            BEGIN
                :NEW.UpdatedAt := SYSDATE;
                :NEW.Version := :OLD.Version + 1;
            END;");

        // Create audit table and trigger
        Create.Table("ProductsAudit")
            .WithColumn("AuditId").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("ProductId").AsInt32().NotNullable()
            .WithColumn("Operation").AsString(10).NotNullable()
            .WithColumn("OldName").AsString(100).Nullable()
            .WithColumn("NewName").AsString(100).Nullable()
            .WithColumn("OldPrice").AsDecimal(10, 2).Nullable()
            .WithColumn("NewPrice").AsDecimal(10, 2).Nullable()
            .WithColumn("ChangedBy").AsString(100).NotNullable()
            .WithColumn("ChangedAt").AsDateTime().NotNullable();

        Execute.Sql("CREATE SEQUENCE SEQ_ProductsAudit START WITH 1 INCREMENT BY 1");

        Execute.Sql(@"
            CREATE OR REPLACE TRIGGER TR_ProductsAudit_BI
            BEFORE INSERT ON ProductsAudit
            FOR EACH ROW
            BEGIN
                SELECT SEQ_ProductsAudit.NEXTVAL INTO :NEW.AuditId FROM DUAL;
            END;");

        // Comprehensive audit trigger
        Execute.Sql(@"
            CREATE OR REPLACE TRIGGER TR_Products_Audit
            AFTER INSERT OR UPDATE OR DELETE ON Products
            FOR EACH ROW
            BEGIN
                IF INSERTING THEN
                    INSERT INTO ProductsAudit (ProductId, Operation, NewName, NewPrice, ChangedBy, ChangedAt)
                    VALUES (:NEW.Id, 'INSERT', :NEW.Name, :NEW.Price, USER, SYSDATE);
                ELSIF UPDATING THEN
                    INSERT INTO ProductsAudit (ProductId, Operation, OldName, NewName, OldPrice, NewPrice, ChangedBy, ChangedAt)
                    VALUES (:NEW.Id, 'UPDATE', :OLD.Name, :NEW.Name, :OLD.Price, :NEW.Price, USER, SYSDATE);
                ELSIF DELETING THEN
                    INSERT INTO ProductsAudit (ProductId, Operation, OldName, OldPrice, ChangedBy, ChangedAt)
                    VALUES (:OLD.Id, 'DELETE', :OLD.Name, :OLD.Price, USER, SYSDATE);
                END IF;
            END;");
    }

    public override void Down()
    {
        Execute.Sql("DROP TRIGGER TR_Products_Audit");
        Execute.Sql("DROP TRIGGER TR_ProductsAudit_BI");
        Execute.Sql("DROP SEQUENCE SEQ_ProductsAudit");
        Delete.Table("ProductsAudit");
        Execute.Sql("DROP TRIGGER TR_Products_BU");
        Execute.Sql("DROP TRIGGER TR_Products_BI");
        Execute.Sql("DROP SEQUENCE SEQ_Products");
        Delete.Table("Products");
    }
}
```

### Oracle Packages and Stored Procedures

```csharp
public class OraclePackagesAndProcedures : Migration
{
    public override void Up()
    {
        Create.Table("Employees")
            .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("FirstName").AsString(50).NotNullable()
            .WithColumn("LastName").AsString(50).NotNullable()
            .WithColumn("Email").AsString(255).NotNullable()
            .WithColumn("DepartmentId").AsInt32().NotNullable()
            .WithColumn("Salary").AsDecimal(10, 2).NotNullable()
            .WithColumn("HireDate").AsDateTime().NotNullable()
            .WithColumn("IsActive").AsCustom("NUMBER(1)").NotNullable().WithDefaultValue(1);

        Execute.Sql("CREATE SEQUENCE SEQ_Employees START WITH 1 INCREMENT BY 1");

        // Create package specification
        Execute.Sql(@"
            CREATE OR REPLACE PACKAGE PKG_Employee_Management AS
                -- Procedures
                PROCEDURE AddEmployee(
                    p_FirstName IN VARCHAR2,
                    p_LastName IN VARCHAR2,
                    p_Email IN VARCHAR2,
                    p_DepartmentId IN NUMBER,
                    p_Salary IN NUMBER,
                    p_EmployeeId OUT NUMBER
                );

                PROCEDURE UpdateEmployeeSalary(
                    p_EmployeeId IN NUMBER,
                    p_NewSalary IN NUMBER,
                    p_Success OUT NUMBER
                );

                PROCEDURE DeactivateEmployee(
                    p_EmployeeId IN NUMBER
                );

                -- Functions
                FUNCTION GetEmployeeFullName(p_EmployeeId IN NUMBER) RETURN VARCHAR2;

                FUNCTION GetDepartmentEmployeeCount(p_DepartmentId IN NUMBER) RETURN NUMBER;

                FUNCTION CalculateAnnualBonus(
                    p_EmployeeId IN NUMBER,
                    p_BonusPercentage IN NUMBER DEFAULT 0.05
                ) RETURN NUMBER;

                -- Cursor
                CURSOR cur_ActiveEmployees RETURN Employees%ROWTYPE;

                -- Constants
                MIN_SALARY CONSTANT NUMBER := 30000;
                MAX_SALARY CONSTANT NUMBER := 300000;
            END PKG_Employee_Management;");

        // Create package body
        Execute.Sql(@"
            CREATE OR REPLACE PACKAGE BODY PKG_Employee_Management AS

                PROCEDURE AddEmployee(
                    p_FirstName IN VARCHAR2,
                    p_LastName IN VARCHAR2,
                    p_Email IN VARCHAR2,
                    p_DepartmentId IN NUMBER,
                    p_Salary IN NUMBER,
                    p_EmployeeId OUT NUMBER
                ) AS
                BEGIN
                    -- Validate salary range
                    IF p_Salary < MIN_SALARY OR p_Salary > MAX_SALARY THEN
                        RAISE_APPLICATION_ERROR(-20001, 'Salary must be between ' || MIN_SALARY || ' and ' || MAX_SALARY);
                    END IF;

                    -- Get next ID
                    SELECT SEQ_Employees.NEXTVAL INTO p_EmployeeId FROM DUAL;

                    -- Insert employee
                    INSERT INTO Employees (Id, FirstName, LastName, Email, DepartmentId, Salary, HireDate, IsActive)
                    VALUES (p_EmployeeId, p_FirstName, p_LastName, p_Email, p_DepartmentId, p_Salary, SYSDATE, 1);

                    COMMIT;
                EXCEPTION
                    WHEN OTHERS THEN
                        ROLLBACK;
                        RAISE;
                END AddEmployee;

                PROCEDURE UpdateEmployeeSalary(
                    p_EmployeeId IN NUMBER,
                    p_NewSalary IN NUMBER,
                    p_Success OUT NUMBER
                ) AS
                    v_Count NUMBER;
                BEGIN
                    p_Success := 0;

                    -- Check if employee exists and is active
                    SELECT COUNT(*) INTO v_Count
                    FROM Employees
                    WHERE Id = p_EmployeeId AND IsActive = 1;

                    IF v_Count = 0 THEN
                        RETURN;
                    END IF;

                    -- Validate salary
                    IF p_NewSalary < MIN_SALARY OR p_NewSalary > MAX_SALARY THEN
                        RAISE_APPLICATION_ERROR(-20001, 'Invalid salary range');
                    END IF;

                    -- Update salary
                    UPDATE Employees
                    SET Salary = p_NewSalary
                    WHERE Id = p_EmployeeId;

                    p_Success := 1;
                    COMMIT;
                EXCEPTION
                    WHEN OTHERS THEN
                        ROLLBACK;
                        p_Success := 0;
                        RAISE;
                END UpdateEmployeeSalary;

                PROCEDURE DeactivateEmployee(p_EmployeeId IN NUMBER) AS
                BEGIN
                    UPDATE Employees
                    SET IsActive = 0
                    WHERE Id = p_EmployeeId;
                    COMMIT;
                END DeactivateEmployee;

                FUNCTION GetEmployeeFullName(p_EmployeeId IN NUMBER) RETURN VARCHAR2 AS
                    v_FullName VARCHAR2(200);
                BEGIN
                    SELECT FirstName || ' ' || LastName
                    INTO v_FullName
                    FROM Employees
                    WHERE Id = p_EmployeeId;

                    RETURN v_FullName;
                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        RETURN NULL;
                END GetEmployeeFullName;

                FUNCTION GetDepartmentEmployeeCount(p_DepartmentId IN NUMBER) RETURN NUMBER AS
                    v_Count NUMBER;
                BEGIN
                    SELECT COUNT(*)
                    INTO v_Count
                    FROM Employees
                    WHERE DepartmentId = p_DepartmentId AND IsActive = 1;

                    RETURN v_Count;
                END GetDepartmentEmployeeCount;

                FUNCTION CalculateAnnualBonus(
                    p_EmployeeId IN NUMBER,
                    p_BonusPercentage IN NUMBER DEFAULT 0.05
                ) RETURN NUMBER AS
                    v_Salary NUMBER;
                    v_Bonus NUMBER;
                BEGIN
                    SELECT Salary INTO v_Salary
                    FROM Employees
                    WHERE Id = p_EmployeeId AND IsActive = 1;

                    v_Bonus := v_Salary * p_BonusPercentage;
                    RETURN v_Bonus;
                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        RETURN 0;
                END CalculateAnnualBonus;

                -- Cursor implementation
                CURSOR cur_ActiveEmployees RETURN Employees%ROWTYPE IS
                    SELECT * FROM Employees WHERE IsActive = 1;

            END PKG_Employee_Management;");

        // Create standalone procedure
        Execute.Sql(@"
            CREATE OR REPLACE PROCEDURE GenerateEmployeeReport(
                p_DepartmentId IN NUMBER DEFAULT NULL,
                p_Cursor OUT SYS_REFCURSOR
            ) AS
            BEGIN
                IF p_DepartmentId IS NULL THEN
                    OPEN p_Cursor FOR
                        SELECT
                            Id,
                            FirstName || ' ' || LastName as FullName,
                            Email,
                            DepartmentId,
                            Salary,
                            HireDate
                        FROM Employees
                        WHERE IsActive = 1
                        ORDER BY LastName, FirstName;
                ELSE
                    OPEN p_Cursor FOR
                        SELECT
                            Id,
                            FirstName || ' ' || LastName as FullName,
                            Email,
                            DepartmentId,
                            Salary,
                            HireDate
                        FROM Employees
                        WHERE DepartmentId = p_DepartmentId AND IsActive = 1
                        ORDER BY LastName, FirstName;
                END IF;
            END GenerateEmployeeReport;");
    }

    public override void Down()
    {
        Execute.Sql("DROP PROCEDURE GenerateEmployeeReport");
        Execute.Sql("DROP PACKAGE PKG_Employee_Management");
        Execute.Sql("DROP SEQUENCE SEQ_Employees");
        Delete.Table("Employees");
    }
}
```

## Oracle Indexes and Performance

### Oracle Index Types

```csharp
public class OracleIndexTypes : Migration
{
    public override void Up()
    {
        Create.Table("LargeTable")
            .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("Name").AsString(100).NotNullable()
            .WithColumn("Category").AsString(50).NotNullable()
            .WithColumn("Amount").AsDecimal(15, 2).NotNullable()
            .WithColumn("CreatedDate").AsDateTime().NotNullable()
            .WithColumn("Status").AsString(20).NotNullable()
            .WithColumn("Description").AsString(4000).Nullable()
            .WithColumn("Keywords").AsString(2000).Nullable();

        // B-tree index (default)
        Create.Index("IX_LargeTable_Name")
            .OnTable("LargeTable")
            .OnColumn("Name");

        // Composite index
        Create.Index("IX_LargeTable_Category_Status")
            .OnTable("LargeTable")
            .OnColumn("Category")
            .OnColumn("Status");

        // Unique index
        Create.Index("UQ_LargeTable_Name_Category")
            .OnTable("LargeTable")
            .OnColumn("Name")
            .OnColumn("Category")
            .Unique();

        // Function-based index
        Execute.Sql("CREATE INDEX IX_LargeTable_Upper_Name ON LargeTable (UPPER(Name))");

        // Bitmap index (good for low cardinality columns)
        Execute.Sql("CREATE BITMAP INDEX IX_LargeTable_Status_Bitmap ON LargeTable (Status)");
        Execute.Sql("CREATE BITMAP INDEX IX_LargeTable_Category_Bitmap ON LargeTable (Category)");

        // Reverse key index (good for sequential inserts)
        Execute.Sql("CREATE INDEX IX_LargeTable_Id_Reverse ON LargeTable (Id) REVERSE");

        // Compressed index
        Execute.Sql("CREATE INDEX IX_LargeTable_CreatedDate_Compressed ON LargeTable (CreatedDate) COMPRESS");

        // Domain index for text search (if Oracle Text is available)
        Execute.Sql(@"
            BEGIN
                EXECUTE IMMEDIATE 'CREATE INDEX IX_LargeTable_Text ON LargeTable (Description) INDEXTYPE IS CTXSYS.CONTEXT';
            EXCEPTION
                WHEN OTHERS THEN
                    NULL; -- Oracle Text not available
            END;");

        // Partitioned index (if table is partitioned)
        Execute.Sql(@"
            CREATE INDEX IX_LargeTable_Amount_Local
            ON LargeTable (Amount)
            LOCAL");
    }

    public override void Down()
    {
        Execute.Sql("DROP INDEX IX_LargeTable_Text");
        Delete.Table("LargeTable");
    }
}
```

### Oracle Materialized Views

```csharp
public class OracleMaterializedViews : Migration
{
    public override void Up()
    {
        // Create base tables
        Create.Table("Orders")
            .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("CustomerId").AsInt32().NotNullable()
            .WithColumn("OrderDate").AsDateTime().NotNullable()
            .WithColumn("TotalAmount").AsDecimal(10, 2).NotNullable()
            .WithColumn("Status").AsString(20).NotNullable();

        Create.Table("OrderItems")
            .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("OrderId").AsInt32().NotNullable()
            .WithColumn("ProductId").AsInt32().NotNullable()
            .WithColumn("Quantity").AsInt32().NotNullable()
            .WithColumn("UnitPrice").AsDecimal(10, 2).NotNullable();

        // Simple materialized view with complete refresh
        Execute.Sql(@"
            CREATE MATERIALIZED VIEW MV_DailySales
            BUILD IMMEDIATE
            REFRESH COMPLETE ON DEMAND
            AS
            SELECT
                TRUNC(OrderDate) as SaleDate,
                COUNT(*) as OrderCount,
                SUM(TotalAmount) as TotalSales,
                AVG(TotalAmount) as AvgOrderValue
            FROM Orders
            WHERE Status = 'COMPLETED'
            GROUP BY TRUNC(OrderDate)");

        // Materialized view with fast refresh (requires materialized view log)
        Execute.Sql(@"
            CREATE MATERIALIZED VIEW LOG ON Orders
            WITH ROWID, SEQUENCE (CustomerId, OrderDate, TotalAmount, Status)
            INCLUDING NEW VALUES");

        Execute.Sql(@"
            CREATE MATERIALIZED VIEW MV_CustomerSales
            BUILD IMMEDIATE
            REFRESH FAST ON DEMAND
            AS
            SELECT
                CustomerId,
                COUNT(*) as OrderCount,
                SUM(TotalAmount) as TotalSales,
                MAX(OrderDate) as LastOrderDate
            FROM Orders
            WHERE Status = 'COMPLETED'
            GROUP BY CustomerId");

        // Materialized view with automatic refresh
        Execute.Sql(@"
            CREATE MATERIALIZED VIEW MV_ProductSales
            BUILD IMMEDIATE
            REFRESH COMPLETE ON COMMIT
            AS
            SELECT
                oi.ProductId,
                COUNT(DISTINCT o.Id) as OrderCount,
                SUM(oi.Quantity) as TotalQuantity,
                SUM(oi.Quantity * oi.UnitPrice) as TotalRevenue
            FROM Orders o
            INNER JOIN OrderItems oi ON o.Id = oi.OrderId
            WHERE o.Status = 'COMPLETED'
            GROUP BY oi.ProductId");

        // Create indexes on materialized views
        Execute.Sql("CREATE INDEX IX_MV_DailySales_SaleDate ON MV_DailySales (SaleDate)");
        Execute.Sql("CREATE INDEX IX_MV_CustomerSales_CustomerId ON MV_CustomerSales (CustomerId)");
        Execute.Sql("CREATE INDEX IX_MV_ProductSales_ProductId ON MV_ProductSales (ProductId)");
    }

    public override void Down()
    {
        Execute.Sql("DROP INDEX IX_MV_ProductSales_ProductId");
        Execute.Sql("DROP INDEX IX_MV_CustomerSales_CustomerId");
        Execute.Sql("DROP INDEX IX_MV_DailySales_SaleDate");
        Execute.Sql("DROP MATERIALIZED VIEW MV_ProductSales");
        Execute.Sql("DROP MATERIALIZED VIEW MV_CustomerSales");
        Execute.Sql("DROP MATERIALIZED VIEW LOG ON Orders");
        Execute.Sql("DROP MATERIALIZED VIEW MV_DailySales");
        Delete.Table("OrderItems");
        Delete.Table("Orders");
    }
}
```

## Oracle Security and User Management

### Oracle User Management and Privileges

```csharp
public class OracleUserManagement : Migration
{
    public override void Up()
    {
        // Create application roles
        Execute.Sql("CREATE ROLE APP_READ_ROLE");
        Execute.Sql("CREATE ROLE APP_WRITE_ROLE");
        Execute.Sql("CREATE ROLE APP_ADMIN_ROLE");

        // Create application users (this would typically be done by DBA)
        try
        {
            Execute.Sql("CREATE USER app_reader IDENTIFIED BY reader_password DEFAULT TABLESPACE USERS");
            Execute.Sql("CREATE USER app_writer IDENTIFIED BY writer_password DEFAULT TABLESPACE USERS");
            Execute.Sql("CREATE USER app_admin IDENTIFIED BY admin_password DEFAULT TABLESPACE USERS");

            // Grant basic privileges
            Execute.Sql("GRANT CREATE SESSION TO app_reader");
            Execute.Sql("GRANT CREATE SESSION TO app_writer");
            Execute.Sql("GRANT CREATE SESSION TO app_admin");

            // Grant roles to users
            Execute.Sql("GRANT APP_READ_ROLE TO app_reader");
            Execute.Sql("GRANT APP_READ_ROLE, APP_WRITE_ROLE TO app_writer");
            Execute.Sql("GRANT APP_READ_ROLE, APP_WRITE_ROLE, APP_ADMIN_ROLE TO app_admin");
        }
        catch
        {
            // Users may already exist or we may not have privileges to create them
        }

        // Create security tables
        Create.Table("AppUsers")
            .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("Username").AsString(50).NotNullable()
            .WithColumn("PasswordHash").AsString(255).NotNullable()
            .WithColumn("Salt").AsString(50).NotNullable()
            .WithColumn("Email").AsString(255).NotNullable()
            .WithColumn("IsActive").AsCustom("NUMBER(1)").NotNullable().WithDefaultValue(1)
            .WithColumn("CreatedAt").AsDateTime().NotNullable()
            .WithColumn("LastLoginAt").AsDateTime().Nullable()
            .WithColumn("FailedAttempts").AsInt32().NotNullable().WithDefaultValue(0)
            .WithColumn("LockedUntil").AsDateTime().Nullable();

        Create.Table("UserRoles")
            .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("UserId").AsInt32().NotNullable()
            .WithColumn("RoleName").AsString(50).NotNullable()
            .WithColumn("GrantedAt").AsDateTime().NotNullable()
            .WithColumn("GrantedBy").AsInt32().NotNullable();

        // Grant privileges to roles
        Execute.Sql("GRANT SELECT ON AppUsers TO APP_READ_ROLE");
        Execute.Sql("GRANT SELECT ON UserRoles TO APP_READ_ROLE");

        Execute.Sql("GRANT SELECT, INSERT, UPDATE ON AppUsers TO APP_WRITE_ROLE");
        Execute.Sql("GRANT SELECT, INSERT, UPDATE, DELETE ON UserRoles TO APP_WRITE_ROLE");

        Execute.Sql("GRANT ALL ON AppUsers TO APP_ADMIN_ROLE");
        Execute.Sql("GRANT ALL ON UserRoles TO APP_ADMIN_ROLE");

        // Create VPD (Virtual Private Database) policy for row-level security
        Execute.Sql(@"
            CREATE OR REPLACE FUNCTION user_security_policy(
                schema_var IN VARCHAR2,
                table_var IN VARCHAR2
            ) RETURN VARCHAR2 AS
            BEGIN
                -- Only return records for the current user or if user is admin
                IF SYS_CONTEXT('USERENV', 'SESSION_USER') = 'APP_ADMIN' THEN
                    RETURN '1=1'; -- No restriction for admin
                ELSE
                    RETURN 'Username = SYS_CONTEXT(''USERENV'', ''SESSION_USER'')';
                END IF;
            END;");

        // Apply the policy (commented out as it requires DBMS_RLS package)
        /*
        Execute.Sql(@"
            BEGIN
                DBMS_RLS.ADD_POLICY(
                    object_schema => USER,
                    object_name => 'AppUsers',
                    policy_name => 'user_isolation_policy',
                    function_schema => USER,
                    policy_function => 'user_security_policy'
                );
            END;");
        */
    }

    public override void Down()
    {
        /*
        Execute.Sql(@"
            BEGIN
                DBMS_RLS.DROP_POLICY(USER, 'AppUsers', 'user_isolation_policy');
            EXCEPTION
                WHEN OTHERS THEN NULL;
            END;");
        */

        Execute.Sql("DROP FUNCTION user_security_policy");
        Delete.Table("UserRoles");
        Delete.Table("AppUsers");

        try
        {
            Execute.Sql("DROP USER app_admin CASCADE");
            Execute.Sql("DROP USER app_writer CASCADE");
            Execute.Sql("DROP USER app_reader CASCADE");
        }
        catch
        {
            // May not have privileges to drop users
        }

        Execute.Sql("DROP ROLE APP_ADMIN_ROLE");
        Execute.Sql("DROP ROLE APP_WRITE_ROLE");
        Execute.Sql("DROP ROLE APP_READ_ROLE");
    }
}
```

## Oracle Advanced Features

### Oracle XML and JSON Support

```csharp
public class OracleXmlJsonSupport : Migration
{
    public override void Up()
    {
        // XML data type (Oracle 9i+)
        Create.Table("XmlDocuments")
            .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("DocumentName").AsString(100).NotNullable()
            .WithColumn("XmlContent").AsCustom("XMLType").NotNullable()
            .WithColumn("CreatedAt").AsDateTime().NotNullable();

        Execute.Sql("CREATE SEQUENCE SEQ_XmlDocuments START WITH 1 INCREMENT BY 1");

        // JSON data type (Oracle 12.2+)
        try
        {
            Execute.Sql(@"
                CREATE TABLE JsonDocuments (
                    Id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    DocumentName VARCHAR2(100) NOT NULL,
                    JsonContent CLOB CHECK (JsonContent IS JSON),
                    CreatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )");
        }
        catch
        {
            // Fallback for older Oracle versions
            Create.Table("JsonDocuments")
                .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
                .WithColumn("DocumentName").AsString(100).NotNullable()
                .WithColumn("JsonContent").AsCustom("CLOB").NotNullable()
                .WithColumn("CreatedAt").AsDateTime().NotNullable();

            Execute.Sql("CREATE SEQUENCE SEQ_JsonDocuments START WITH 1 INCREMENT BY 1");
        }

        // Insert XML data
        Execute.Sql(@"
            INSERT INTO XmlDocuments (Id, DocumentName, XmlContent, CreatedAt)
            VALUES (SEQ_XmlDocuments.NEXTVAL, 'Sample Document',
                    XMLType('<root><person><name>John Doe</name><age>30</age></person></root>'),
                    SYSDATE)");

        // Insert JSON data (Oracle 12.2+)
        try
        {
            Execute.Sql(@"
                INSERT INTO JsonDocuments (DocumentName, JsonContent)
                VALUES ('Sample JSON', '{""name"": ""John Doe"", ""age"": 30, ""city"": ""New York""}')");
        }
        catch
        {
            Execute.Sql(@"
                INSERT INTO JsonDocuments (Id, DocumentName, JsonContent, CreatedAt)
                VALUES (SEQ_JsonDocuments.NEXTVAL, 'Sample JSON',
                        '{""name"": ""John Doe"", ""age"": 30, ""city"": ""New York""}',
                        SYSDATE)");
        }

        // Create indexes for XML querying
        Execute.Sql(@"
            CREATE INDEX IX_XmlDocuments_Name
            ON XmlDocuments (
                EXTRACTVALUE(XmlContent, '/root/person/name')
            )");

        // Create indexes for JSON querying (Oracle 12.2+)
        try
        {
            Execute.Sql(@"
                CREATE INDEX IX_JsonDocuments_Name
                ON JsonDocuments (JSON_VALUE(JsonContent, '$.name'))");

            Execute.Sql(@"
                CREATE INDEX IX_JsonDocuments_Age
                ON JsonDocuments (JSON_VALUE(JsonContent, '$.age' RETURNING NUMBER))");
        }
        catch
        {
            // JSON functions not available
        }

        // Create views for easier querying
        Execute.Sql(@"
            CREATE VIEW XmlDocumentView AS
            SELECT
                Id,
                DocumentName,
                EXTRACTVALUE(XmlContent, '/root/person/name') as PersonName,
                EXTRACTVALUE(XmlContent, '/root/person/age') as PersonAge,
                CreatedAt
            FROM XmlDocuments");

        try
        {
            Execute.Sql(@"
                CREATE VIEW JsonDocumentView AS
                SELECT
                    Id,
                    DocumentName,
                    JSON_VALUE(JsonContent, '$.name') as PersonName,
                    JSON_VALUE(JsonContent, '$.age' RETURNING NUMBER) as PersonAge,
                    JSON_VALUE(JsonContent, '$.city') as PersonCity,
                    CreatedAt
                FROM JsonDocuments");
        }
        catch
        {
            // Fallback view for older Oracle versions
            Execute.Sql(@"
                CREATE VIEW JsonDocumentView AS
                SELECT
                    Id,
                    DocumentName,
                    JsonContent,
                    CreatedAt
                FROM JsonDocuments");
        }
    }

    public override void Down()
    {
        Execute.Sql("DROP VIEW JsonDocumentView");
        Execute.Sql("DROP VIEW XmlDocumentView");

        try
        {
            Execute.Sql("DROP SEQUENCE SEQ_JsonDocuments");
        }
        catch { }

        Delete.Table("JsonDocuments");
        Execute.Sql("DROP SEQUENCE SEQ_XmlDocuments");
        Delete.Table("XmlDocuments");
    }
}
```

## Oracle Performance Tuning

### Oracle Hints and Query Optimization

```csharp
public class OraclePerformanceTuning : Migration
{
    public override void Up()
    {
        Create.Table("PerformanceTestData")
            .WithColumn("Id").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("CategoryId").AsInt32().NotNullable()
            .WithColumn("SubCategoryId").AsInt32().NotNullable()
            .WithColumn("Status").AsString(20).NotNullable()
            .WithColumn("Amount").AsDecimal(15, 2).NotNullable()
            .WithColumn("ProcessDate").AsDateTime().NotNullable()
            .WithColumn("Description").AsString(2000).Nullable()
            .WithColumn("SearchText").AsString(4000).Nullable();

        Execute.Sql("CREATE SEQUENCE SEQ_PerformanceTestData START WITH 1 INCREMENT BY 1");

        // Create optimal indexes
        Create.Index("IX_PerformanceTestData_CategoryId")
            .OnTable("PerformanceTestData")
            .OnColumn("CategoryId");

        Create.Index("IX_PerformanceTestData_Status_ProcessDate")
            .OnTable("PerformanceTestData")
            .OnColumn("Status")
            .OnColumn("ProcessDate");

        // Bitmap indexes for low cardinality columns
        Execute.Sql("CREATE BITMAP INDEX IX_PerformanceTestData_Status_BM ON PerformanceTestData (Status)");
        Execute.Sql("CREATE BITMAP INDEX IX_PerformanceTestData_Category_BM ON PerformanceTestData (CategoryId)");

        // Function-based index for case-insensitive searches
        Execute.Sql("CREATE INDEX IX_PerformanceTestData_Description_Upper ON PerformanceTestData (UPPER(Description))");

        // Create statistics gathering procedure
        Execute.Sql(@"
            CREATE OR REPLACE PROCEDURE GatherTableStatistics AS
            BEGIN
                -- Gather table statistics
                DBMS_STATS.GATHER_TABLE_STATS(
                    ownname => USER,
                    tabname => 'PerformanceTestData',
                    estimate_percent => 20,
                    method_opt => 'FOR ALL COLUMNS SIZE AUTO',
                    degree => 4,
                    cascade => TRUE
                );
            END;");

        // Create performance monitoring view
        Execute.Sql(@"
            CREATE VIEW PerformanceMetrics AS
            SELECT
                'PerformanceTestData' as TableName,
                COUNT(*) as RowCount,
                COUNT(DISTINCT CategoryId) as UniqueCategoriesCount,
                COUNT(DISTINCT Status) as UniqueStatusCount,
                MIN(ProcessDate) as EarliestDate,
                MAX(ProcessDate) as LatestDate,
                AVG(Amount) as AvgAmount,
                SUM(Amount) as TotalAmount
            FROM PerformanceTestData");

        // Example performance queries with hints (for documentation)
        Execute.Sql(@"
            -- Performance optimization examples with hints:

            -- Use specific index
            -- SELECT /*+ INDEX(p IX_PerformanceTestData_CategoryId) */ *
            -- FROM PerformanceTestData p
            -- WHERE CategoryId = 1;

            -- Force parallel execution
            -- SELECT /*+ PARALLEL(p, 4) */ CategoryId, COUNT(*), SUM(Amount)
            -- FROM PerformanceTestData p
            -- GROUP BY CategoryId;

            -- Use hash join
            -- SELECT /*+ USE_HASH(p1, p2) */ p1.Id, p2.Amount
            -- FROM PerformanceTestData p1
            -- JOIN PerformanceTestData p2 ON p1.CategoryId = p2.SubCategoryId;

            -- First rows optimization
            -- SELECT /*+ FIRST_ROWS(10) */ *
            -- FROM PerformanceTestData
            -- WHERE Status = 'ACTIVE'
            -- ORDER BY ProcessDate DESC;

            -- All rows optimization
            -- SELECT /*+ ALL_ROWS */ CategoryId, SUM(Amount)
            -- FROM PerformanceTestData
            -- WHERE Status = 'COMPLETED'
            -- GROUP BY CategoryId;
            ");
    }

    public override void Down()
    {
        Execute.Sql("DROP VIEW PerformanceMetrics");
        Execute.Sql("DROP PROCEDURE GatherTableStatistics");
        Execute.Sql("DROP SEQUENCE SEQ_PerformanceTestData");
        Delete.Table("PerformanceTestData");
    }
}
```

## Oracle Best Practices

### Oracle Naming Conventions and Standards

```csharp
public class OracleNamingConventions : Migration
{
    public override void Up()
    {
        // Oracle naming conventions:
        // - Table names: UPPER_CASE with underscores
        // - Column names: UPPER_CASE with underscores
        // - Indexes: IX_TABLENAME_COLUMNS or UQ_TABLENAME_COLUMNS
        // - Sequences: SEQ_TABLENAME
        // - Triggers: TR_TABLENAME_TIMING
        // - Foreign keys: FK_CHILDTABLE_PARENTTABLE

        Create.Table("CUSTOMER_ORDERS")
            .WithColumn("ORDER_ID").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("CUSTOMER_ID").AsInt32().NotNullable()
            .WithColumn("ORDER_NUMBER").AsString(20).NotNullable()
            .WithColumn("ORDER_DATE").AsDateTime().NotNullable()
            .WithColumn("TOTAL_AMOUNT").AsDecimal(15, 2).NotNullable()
            .WithColumn("STATUS_CODE").AsString(20).NotNullable()
            .WithColumn("CREATED_BY").AsString(100).NotNullable()
            .WithColumn("CREATED_DATE").AsDateTime().NotNullable()
            .WithColumn("MODIFIED_BY").AsString(100).Nullable()
            .WithColumn("MODIFIED_DATE").AsDateTime().Nullable()
            .WithColumn("VERSION_NUMBER").AsInt32().NotNullable().WithDefaultValue(1);

        Create.Table("ORDER_LINE_ITEMS")
            .WithColumn("LINE_ITEM_ID").AsInt32().NotNullable().PrimaryKey()
            .WithColumn("ORDER_ID").AsInt32().NotNullable()
            .WithColumn("PRODUCT_ID").AsInt32().NotNullable()
            .WithColumn("QUANTITY").AsInt32().NotNullable()
            .WithColumn("UNIT_PRICE").AsDecimal(10, 2).NotNullable()
            .WithColumn("LINE_TOTAL").AsDecimal(15, 2).NotNullable()
            .WithColumn("DISCOUNT_PERCENT").AsDecimal(5, 2).Nullable()
            .WithColumn("CREATED_DATE").AsDateTime().NotNullable();

        // Sequences following naming convention
        Execute.Sql("CREATE SEQUENCE SEQ_CUSTOMER_ORDERS START WITH 1 INCREMENT BY 1");
        Execute.Sql("CREATE SEQUENCE SEQ_ORDER_LINE_ITEMS START WITH 1 INCREMENT BY 1");

        // Indexes following naming convention
        Create.Index("IX_CUSTOMER_ORDERS_CUSTOMER_ID")
            .OnTable("CUSTOMER_ORDERS")
            .OnColumn("CUSTOMER_ID");

        Create.Index("IX_CUSTOMER_ORDERS_ORDER_DATE")
            .OnTable("CUSTOMER_ORDERS")
            .OnColumn("ORDER_DATE");

        Create.Index("UQ_CUSTOMER_ORDERS_ORDER_NUMBER")
            .OnTable("CUSTOMER_ORDERS")
            .OnColumn("ORDER_NUMBER")
            .Unique();

        Create.Index("IX_ORDER_LINE_ITEMS_ORDER_ID")
            .OnTable("ORDER_LINE_ITEMS")
            .OnColumn("ORDER_ID");

        Create.Index("IX_ORDER_LINE_ITEMS_PRODUCT_ID")
            .OnTable("ORDER_LINE_ITEMS")
            .OnColumn("PRODUCT_ID");

        // Foreign keys following naming convention
        Create.ForeignKey("FK_ORDER_LINE_ITEMS_CUSTOMER_ORDERS")
            .FromTable("ORDER_LINE_ITEMS").ForeignColumn("ORDER_ID")
            .ToTable("CUSTOMER_ORDERS").PrimaryColumn("ORDER_ID");

        // Triggers following naming convention
        Execute.Sql(@"
            CREATE OR REPLACE TRIGGER TR_CUSTOMER_ORDERS_BI
            BEFORE INSERT ON CUSTOMER_ORDERS
            FOR EACH ROW
            BEGIN
                IF :NEW.ORDER_ID IS NULL THEN
                    SELECT SEQ_CUSTOMER_ORDERS.NEXTVAL INTO :NEW.ORDER_ID FROM DUAL;
                END IF;

                :NEW.CREATED_DATE := SYSDATE;
                :NEW.MODIFIED_DATE := SYSDATE;
            END;");

        Execute.Sql(@"
            CREATE OR REPLACE TRIGGER TR_CUSTOMER_ORDERS_BU
            BEFORE UPDATE ON CUSTOMER_ORDERS
            FOR EACH ROW
            BEGIN
                :NEW.MODIFIED_DATE := SYSDATE;
                :NEW.VERSION_NUMBER := :OLD.VERSION_NUMBER + 1;
            END;");

        Execute.Sql(@"
            CREATE OR REPLACE TRIGGER TR_ORDER_LINE_ITEMS_BI
            BEFORE INSERT ON ORDER_LINE_ITEMS
            FOR EACH ROW
            BEGIN
                IF :NEW.LINE_ITEM_ID IS NULL THEN
                    SELECT SEQ_ORDER_LINE_ITEMS.NEXTVAL INTO :NEW.LINE_ITEM_ID FROM DUAL;
                END IF;

                :NEW.CREATED_DATE := SYSDATE;

                -- Calculate line total
                :NEW.LINE_TOTAL := :NEW.QUANTITY * :NEW.UNIT_PRICE;

                -- Apply discount if specified
                IF :NEW.DISCOUNT_PERCENT IS NOT NULL THEN
                    :NEW.LINE_TOTAL := :NEW.LINE_TOTAL * (1 - :NEW.DISCOUNT_PERCENT / 100);
                END IF;
            END;");
    }

    public override void Down()
    {
        Execute.Sql("DROP TRIGGER TR_ORDER_LINE_ITEMS_BI");
        Execute.Sql("DROP TRIGGER TR_CUSTOMER_ORDERS_BU");
        Execute.Sql("DROP TRIGGER TR_CUSTOMER_ORDERS_BI");
        Delete.ForeignKey("FK_ORDER_LINE_ITEMS_CUSTOMER_ORDERS").OnTable("ORDER_LINE_ITEMS");
        Execute.Sql("DROP SEQUENCE SEQ_ORDER_LINE_ITEMS");
        Execute.Sql("DROP SEQUENCE SEQ_CUSTOMER_ORDERS");
        Delete.Table("ORDER_LINE_ITEMS");
        Delete.Table("CUSTOMER_ORDERS");
    }
}
```

## Troubleshooting Oracle Issues

### Common Oracle Migration Issues

```csharp
public class OracleTroubleshooting : Migration
{
    public override void Up()
    {
        try
        {
            // Issue 1: Long identifier names (Oracle 12.1 allows 128 chars, earlier versions 30)
            var longTableName = "VERY_LONG_TABLE_NAME_THAT_MIGHT_EXCEED_LIMITS";
            if (longTableName.Length > 30)
            {
                longTableName = "LONG_TABLE_NAME"; // Truncate for older Oracle versions
            }

            Create.Table(longTableName)
                .WithColumn("ID").AsInt32().NotNullable().PrimaryKey()
                .WithColumn("DESCRIPTION").AsString(4000).Nullable();

            // Issue 2: Data type precision and scale
            Create.Table("PRECISION_TEST")
                .WithColumn("ID").AsInt32().NotNullable().PrimaryKey()
                .WithColumn("DECIMAL_VALUE").AsDecimal(38, 4).NotNullable() // Oracle max precision is 38
                .WithColumn("NUMBER_VALUE").AsCustom("NUMBER(10,2)").NotNullable()
                .WithColumn("FLOAT_VALUE").AsCustom("FLOAT(126)").Nullable(); // Oracle FLOAT precision

            // Issue 3: Character set and national character set
            Create.Table("CHARACTER_SET_TEST")
                .WithColumn("ID").AsInt32().NotNullable().PrimaryKey()
                .WithColumn("VARCHAR2_COL").AsString(4000).NotNullable() // Max 4000 bytes
                .WithColumn("NVARCHAR2_COL").AsCustom("NVARCHAR2(2000)").Nullable() // Max 2000 chars
                .WithColumn("CHAR_COL").AsFixedLengthString(2000).Nullable() // Max 2000 bytes
                .WithColumn("NCHAR_COL").AsCustom("NCHAR(1000)").Nullable(); // Max 1000 chars

            // Issue 4: Date handling and time zones
            Create.Table("DATE_TEST")
                .WithColumn("ID").AsInt32().NotNullable().PrimaryKey()
                .WithColumn("DATE_COL").AsDateTime().NotNullable()
                .WithColumn("TIMESTAMP_COL").AsCustom("TIMESTAMP").NotNullable()
                .WithColumn("TIMESTAMP_TZ_COL").AsCustom("TIMESTAMP WITH TIME ZONE").Nullable()
                .WithColumn("TIMESTAMP_LTZ_COL").AsCustom("TIMESTAMP WITH LOCAL TIME ZONE").Nullable();

            // Issue 5: Handling NULL vs empty strings (Oracle treats empty string as NULL)
            Insert.IntoTable("CHARACTER_SET_TEST")
                .Row(new
                {
                    ID = 1,
                    VARCHAR2_COL = "Test Value", // Don't use empty string - Oracle converts to NULL
                    NVARCHAR2_COL = "Unicode Test: 测试",
                    CHAR_COL = "Fixed Length",
                    NCHAR_COL = "Unicode Fixed"
                });

            // Issue 6: Foreign key constraint issues
            Execute.Sql("ALTER SESSION SET FOREIGN_KEY_CHECKS = TRUE"); // Oracle equivalent concept

            // Check for orphaned records before creating foreign keys
            var orphanedRecords = Execute.Sql(@"
                SELECT COUNT(*) FROM
                (SELECT 1 FROM DUAL WHERE 1=0) -- Placeholder query
                ").Returns<int>().FirstOrDefault();

            // Issue 7: Sequence and trigger issues
            Execute.Sql("CREATE SEQUENCE SEQ_PRECISION_TEST START WITH 1 INCREMENT BY 1 NOCACHE");

            Execute.Sql(@"
                CREATE OR REPLACE TRIGGER TR_PRECISION_TEST_BI
                BEFORE INSERT ON PRECISION_TEST
                FOR EACH ROW
                WHEN (NEW.ID IS NULL)
                BEGIN
                    SELECT SEQ_PRECISION_TEST.NEXTVAL INTO :NEW.ID FROM DUAL;
                EXCEPTION
                    WHEN OTHERS THEN
                        RAISE_APPLICATION_ERROR(-20001, 'Error in trigger: ' || SQLERRM);
                END;");

        }
        catch (Exception ex)
        {
            Execute.Sql($"-- Migration failed: {ex.Message}");
            throw;
        }
    }

    public override void Down()
    {
        Execute.Sql("DROP TRIGGER TR_PRECISION_TEST_BI");
        Execute.Sql("DROP SEQUENCE SEQ_PRECISION_TEST");
        Delete.Table("DATE_TEST");
        Delete.Table("CHARACTER_SET_TEST");
        Delete.Table("PRECISION_TEST");
        Delete.Table("LONG_TABLE_NAME");
    }
}
```
